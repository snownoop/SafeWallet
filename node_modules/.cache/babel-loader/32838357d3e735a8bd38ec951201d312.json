{"ast":null,"code":"import publicKeyByPrivateKey from './public-key-by-private-key';\nimport { fromPrivate } from 'eth-lib/lib/account';\nimport { keccak256 } from 'eth-lib/lib/hash';\nimport Bytes from 'eth-lib/lib/bytes';\nvar MIN_ENTROPY_SIZE = 128;\n/**\n * create a privateKey from the given entropy or a new one\n * @param  {Buffer} entropy\n * @return {string}\n */\n\nexport function createPrivateKey(entropy) {\n  if (entropy) {\n    if (!Buffer.isBuffer(entropy)) throw new Error('EthCrypto.createPrivateKey(): given entropy is no Buffer');\n    if (Buffer.byteLength(entropy, 'utf8') < MIN_ENTROPY_SIZE) throw new Error('EthCrypto.createPrivateKey(): Entropy-size must be at least ' + MIN_ENTROPY_SIZE);\n    var outerHex = keccak256(entropy);\n    return outerHex;\n  } else {\n    // @link https://github.com/MaiaVictor/eth-lib/blob/master/lib/account.js#L8\n    var innerHex = keccak256(Bytes.concat(Bytes.random(32), Bytes.random(32)));\n    var middleHex = Bytes.concat(Bytes.concat(Bytes.random(32), innerHex), Bytes.random(32));\n\n    var _outerHex = keccak256(middleHex);\n\n    return _outerHex;\n  }\n}\n/**\n * creates a new object with\n * private-, public-Key and address\n * @param {Buffer?} entropy if provided, will use that as single random-source\n */\n\nexport default function createIdentity(entropy) {\n  var privateKey = createPrivateKey(entropy);\n  var identity = fromPrivate(privateKey);\n  identity.publicKey = publicKeyByPrivateKey(identity.privateKey);\n  return identity;\n}","map":null,"metadata":{},"sourceType":"module"}